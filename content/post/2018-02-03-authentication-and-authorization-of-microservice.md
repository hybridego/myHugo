---
layout:     post 
title:      "안전한 마이크로서비스 애플리케이션을 구축하는 방법은?"
subtitle:   "마이크로서비스 아키텍처에서의 인증 및 권한 부여 방안 논의"
description: "마이크로서비스 아키텍처의 도입은 소규모 개발팀, 개발 주기 단축, 언어 선택의 유연성, 서비스 확장성 향상 등 소프트웨어 애플리케이션에 많은 이점을 가져다주었습니다. 동시에 분산 시스템의 복잡한 문제들도 함께 도입되었습니다. 그중 하나의 과제는 마이크로서비스 아키텍처에서 유연하고 안전하며 효율적인 인증 및 권한 부여 방안을 구현하는 것입니다. 이 글에서는 이 문제에 대해 비교적 완전한 논의를 시도할 것입니다."
excerpt: "마이크로서비스 아키텍처의 도입은 소규모 개발팀, 개발 주기 단축, 언어 선택의 유연성, 서비스 확장성 향상 등 소프트웨어 애플리케이션에 많은 이점을 가져다주었습니다. 동시에 분산 시스템의 복잡한 문제들도 함께 도입되었습니다. 그중 하나의 과제는 마이크로서비스 아키텍처에서 유연하고 안전하며 효율적인 인증 및 권한 부여 방안을 구현하는 것입니다. 이 글에서는 이 문제에 대해 비교적 완전한 논의를 시도할 것입니다."
date:       2018-02-03 12:00:00
author:     "Lionel.J"
image: "/img/2018-02-03-authentication-and-authorization-of-microservice/AuthenticationTrack.jpeg"
publishDate: 2018-02-03 12:00:00
tags:
    - Microservice
    - Security
URL: "/2018/05/22/user_authentication_authorization/"
categories: [ Tech ]
---

## 서론

마이크로서비스 아키텍처의 도입은 소프트웨어 애플리케이션에 많은 이점을 가져다주었습니다: 소규모 개발팀, 개발 주기 단축, 언어 선택의 유연성, 서비스 확장성 향상 등. 동시에 분산 시스템의 복잡한 문제들도 함께 도입되었습니다. 그중 하나의 과제는 마이크로서비스 아키텍처에서 유연하고 안전하며 효율적인 인증 및 권한 부여 방안을 구현하는 것입니다. 이 글에서는 이 문제에 대해 비교적 완전한 논의를 시도할 것입니다.
<!--more-->
## 모놀리식 애플리케이션의 구현 방식
모놀리식 아키텍처에서는 전체 애플리케이션이 하나의 프로세스이며, 애플리케이션 내에서는 일반적으로 보안 모듈을 사용하여 사용자 인증 및 권한 부여를 구현합니다.

사용자가 로그인할 때, 애플리케이션의 보안 모듈은 사용자 신원을 검증하고, 사용자 신원이 유효하면 해당 사용자에게 세션(Session)을 생성하고, 이 세션에 고유한 번호(Session Id)를 연결합니다. 세션은 애플리케이션 내의 작은 메모리 구조로, 로그인한 사용자의 정보(예: 사용자 이름, 역할, 권한 등)를 저장합니다. 서버는 해당 세션의 세션 ID를 클라이언트에 반환하고, 클라이언트는 세션 ID를 쿠키 또는 URL 재작성 방식으로 기록하여 후속 요청에서 애플리케이션으로 전송합니다. 이렇게 하면 애플리케이션은 클라이언트의 접근 요청을 받을 때 세션 ID를 사용하여 사용자 신원을 검증할 수 있으며, 매번 요청 시 사용자 이름과 비밀번호를 입력하여 신원 인증을 할 필요가 없습니다.
> 참고: 세션 ID가 제3자에게 가로채이거나 도용되는 것을 방지하기 위해 클라이언트와 애플리케이션 간에는 TLS 암호화 통신을 사용해야 하며, 세션에도 만료 시간을 설정해야 합니다.

![모놀리식 애플리케이션 사용자 로그인 인증 시퀀스 다이어그램](/img/2018-02-03-authentication-and-authorization-of-microservice/monolith-user-login.png)
<center>모놀리식 애플리케이션 사용자 로그인 인증 시퀀스 다이어그램</center>

클라이언트가 애플리케이션에 접근할 때, 세션 ID는 HTTP 요청과 함께 애플리케이션으로 전송됩니다. 클라이언트 요청은 일반적으로 인터셉터를 통해 모든 수신된 클라이언트 요청을 처리합니다. 인터셉터는 먼저 세션 ID의 존재 여부를 판단하고, 해당 세션 ID가 존재하면 해당 사용자가 이미 로그인했음을 알 수 있습니다. 그런 다음 사용자 권한을 조회하여 사용자가 해당 요청을 실행할 수 있는지 판단하여 작업 권한 부여를 구현합니다.
![모놀리식 애플리케이션 사용자 작업 권한 부여 시퀀스 다이어그램](/img/2018-02-03-authentication-and-authorization-of-microservice/monolith-user-request.png)
<center>모놀리식 애플리케이션 사용자 작업 권한 부여 시퀀스 다이어그램</center>

## 마이크로서비스 인증 및 권한 부여가 직면한 문제
마이크로서비스 아키텍처에서는 하나의 애플리케이션이 여러 마이크로서비스 프로세스로 분할되며, 각 마이크로서비스는 원래 모놀리식 애플리케이션의 한 모듈의 비즈니스 기능을 구현합니다. 애플리케이션이 분할된 후, 각 마이크로서비스에 대한 접근 요청은 인증 및 권한 부여를 거쳐야 합니다. 모놀리식 애플리케이션의 구현 방식을 참조하면 다음과 같은 문제에 직면하게 됩니다:
* 인증 및 권한 부여 로직은 각 마이크로서비스에서 처리되어야 하며, 이 공통 로직을 각 마이크로서비스에서 반복적으로 구현해야 합니다. 코드 라이브러리를 사용하여 일부 코드를 재사용할 수 있지만, 이는 모든 마이크로서비스가 특정 코드 라이브러리 및 해당 버전에 의존하게 되어 마이크로서비스 언어/프레임워크 선택의 유연성에 영향을 미칩니다.
* 마이크로서비스는 단일 책임 원칙을 따라야 하며, 하나의 마이크로서비스는 단일 비즈니스 로직만 처리해야 합니다. 인증 및 권한 부여의 공통 로직은 마이크로서비스 구현에 포함되어서는 안 됩니다.
* 마이크로서비스 아키텍처의 이점을 최대한 활용하고 마이크로서비스의 수평 확장성(Scalability)과 탄력성(Resiliency)을 구현하기 위해 마이크로서비스는 무상태(Stateless)여야 합니다. 따라서 세션과 같은 상태 저장 방식은 권장되지 않습니다.
* 마이크로서비스 아키텍처에서의 인증 및 권한 부여는 사용자 마이크로서비스 애플리케이션 접근, 타사 애플리케이션 마이크로서비스 애플리케이션 접근, 애플리케이션 내 여러 마이크로서비스 간 상호 접근 등 더욱 복잡한 시나리오를 포함하며, 각 시나리오에 대한 인증 및 권한 부여 방안을 고려하여 애플리케이션의 보안을 보장해야 합니다.
![마이크로서비스 인증 및 권한 부여와 관련된 세 가지 시나리오](/img/2018-02-03-authentication-and-authorization-of-microservice/auth-scenarios.png)
<center>마이크로서비스 인증 및 권한 부여와 관련된 세 가지 시나리오</center>

## 마이크로서비스 인증 및 권한 부여 기술 방안

### 사용자 신원 인증
완전한 마이크로서비스 애플리케이션은 여러 개의 독립적인 마이크로서비스 프로세스로 구성되며, 각 마이크로서비스에 대한 접근은 사용자 인증을 거쳐야 합니다. 사용자 인증 작업을 각 마이크로서비스에 배치하면 애플리케이션의 인증 로직이 매우 복잡해집니다. 따라서 SSO(Single Sign-On) 방안을 고려해야 합니다. 즉, 사용자는 한 번만 로그인하면 모든 마이크로서비스가 제공하는 서비스에 접근할 수 있습니다. 마이크로서비스 아키텍처에서는 API Gateway가 외부 서비스 제공의 진입점 역할을 하므로, API Gateway에서 통합 사용자 인증을 제공하는 것을 고려할 수 있습니다.

### 사용자 상태 유지
HTTP는 무상태 프로토콜이며, 서버 입장에서는 사용자의 각 HTTP 요청이 서로 독립적입니다. 인터넷은 거대한 분산 시스템이며, HTTP 프로토콜은 인터넷의 중요한 프로토콜로서 대량의 애플리케이션 접근 효율성 문제를 고려해야 합니다. 무상태는 서버가 클라이언트의 요청을 필요에 따라 클러스터의 어떤 노드로든 보낼 수 있음을 의미하며, HTTP의 무상태 설계는 로드 밸런싱에 명확한 이점을 제공합니다. 상태가 없으므로 사용자 요청은 임의의 서버로 분산될 수 있으며, 애플리케이션은 사용자에게 가까운 네트워크 에지에 캐시 서버를 배포할 수도 있습니다. 뉴스 웹 페이지 탐색과 같이 신원 인증이 필요 없는 서비스의 경우 아무런 문제가 없습니다. 그러나 온라인 쇼핑, 기업 관리 시스템 등 많은 서비스는 사용자 신원 인증이 필요하므로, HTTP 프로토콜을 기반으로 사용자 로그인 상태를 저장하는 방식을 채택하여 사용자가 요청을 시작할 때마다 인증할 필요가 없도록 해야 합니다.

전통적인 방식은 서버 측에서 쿠키를 사용하여 사용자 상태를 저장하는 것이었지만, 서버가 상태를 가지므로 서버의 수평 확장에 영향을 미칩니다. 마이크로서비스 아키텍처에서는 토큰을 사용하여 사용자 로그인 상태를 기록하는 것을 권장합니다.

토큰과 세션의 주요 차이점은 저장 위치입니다. 세션은 서버에 중앙 집중식으로 저장되는 반면, 토큰은 사용자가 직접 소유하며 일반적으로 브라우저에 쿠키 형태로 저장됩니다. 토큰에는 사용자 신원 정보가 저장되어 있으며, 매 요청 시 서버로 전송되어 서버가 접근자의 신원을 판단하고 요청된 리소스에 대한 접근 권한이 있는지 판단할 수 있습니다.

토큰은 사용자 신원을 나타내므로, 요청자 또는 제3자에 의한 변조를 방지하기 위해 내용을 암호화해야 합니다. [JWT(Json Web Token)](https://jwt.io)는 토큰 형식(RFC 7519)을 정의하는 개방형 표준으로, 토큰의 내용, 암호화 방식, 그리고 다양한 언어의 라이브러리를 제공합니다.

JWT 토큰의 구조는 매우 간단하며 세 부분으로 구성됩니다:
* 헤더<BR>
헤더에는 유형(고정 값 JWT)과 JWT에서 사용하는 해시 알고리즘이 포함됩니다.
```
{
  "alg": "HS256",
  "typ": "JWT"
}
```
* 페이로드<BR>
발행자, 만료 시간, 사용자 이름 등 표준 정보가 포함되며, 사용자 역할, 사용자 정의 정보도 추가할 수 있습니다.
```
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```
* 서명<BR>
토큰 발행자의 서명으로, 클라이언트가 토큰 발행자의 신원을 확인하고 서버가 토큰 변조를 방지하는 데 사용됩니다.
서명 알고리즘
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

이 세 부분은 Base64로 인코딩된 후 조합되어 최종적으로 클라이언트에 반환되는 토큰 문자열이 되며, 각 부분은 "."으로 구분됩니다. 다음 그림은 위 예시에서 최종적으로 형성된 토큰입니다.
![](https://cdn.auth0.com/content/jwt/encoded-jwt3.png)
토큰을 사용하여 사용자 인증을 수행할 때, 서버는 더 이상 사용자 상태를 저장하지 않으며, 클라이언트는 매 요청 시 토큰을 서버로 전송하여 신원 인증을 수행해야 합니다. 토큰 전송 방식은 [rfc6750](https://tools.ietf.org/html/rfc6750)에 규정되어 있으며, Authorization: Bearer HTTP 헤더를 사용하여 전송합니다.
```
Authorization: Bearer mF_9.B5f-4.1JqM
```
토큰 방식을 사용한 사용자 인증의 기본 흐름은 다음과 같습니다:
1. 사용자가 사용자 이름, 비밀번호 등 인증 정보를 입력하고 서버에 로그인 요청을 보냅니다.
1. 서버는 사용자 로그인 정보를 검증하고 JWT 토큰을 생성합니다.
1. 서버는 토큰을 클라이언트에 반환하고, 클라이언트는 이를 로컬에 저장합니다(일반적으로 쿠키 형태로 저장).
1. 클라이언트는 이전에 발급받은 토큰을 포함하여 서버에 접근 요청을 보냅니다.
1. 서버는 토큰을 검증하여 사용자의 신원과 리소스 접근 권한을 확인하고, 그에 따라 처리합니다(접근 거부 또는 허용).
![](https://cdn.auth0.com/content/jwt/jwt-diagram.png)
<center>토큰을 사용한 사용자 인증 흐름도</center>

### 싱글 사인온 구현
싱글 사인온의 개념은 간단합니다. 사용자가 애플리케이션에 한 번만 로그인하면 애플리케이션의 모든 마이크로서비스에 접근할 수 있다는 것입니다. API Gateway는 클라이언트가 마이크로서비스 애플리케이션에 접근하는 진입점을 제공하며, 토큰은 무상태 사용자 인증을 구현합니다. 이 두 기술을 결합하여 마이크로서비스 애플리케이션에 싱글 사인온 방안을 구현할 수 있습니다.

사용자 인증 흐름은 토큰 방식을 사용한 인증의 기본 흐름과 유사하며, 외부 요청의 진입점으로 API Gateway가 추가된 점이 다릅니다.

사용자 로그인
1. 클라이언트가 API Gateway로 로그인 요청을 보냅니다.
2. API Gateway는 로그인 요청을 Security Service로 전달합니다.
3. Security Service는 사용자 신원을 검증하고 토큰을 발급합니다.

사용자 요청
1. 클라이언트 요청이 API Gateway로 전송됩니다.
1. API Gateway는 Security Service를 호출하여 요청의 토큰을 검증하고 사용자 신원을 확인합니다.
2. 요청에 토큰이 없거나, 토큰이 만료되었거나, 토큰 검증이 유효하지 않으면 사용자 요청을 거부합니다.
3. Security Service는 사용자가 해당 작업 권한을 가지고 있는지 확인합니다.
4. 사용자가 해당 작업 권한을 가지고 있으면 요청을 백엔드 Business Service로 전송하고, 그렇지 않으면 사용자 요청을 거부합니다.
![API Gateway를 사용하여 마이크로서비스 애플리케이션 SSO 구현](/img/2018-02-03-authentication-and-authorization-of-microservice/api-gateway-sso.png)
<center>API Gateway와 토큰을 사용하여 마이크로서비스 애플리케이션의 싱글 사인온 구현</center>

### 사용자 권한 제어
사용자 권한 제어는 API Gateway에서 통합 처리하거나 각 마이크로서비스에서 개별적으로 처리하는 두 가지 방법이 있습니다.
#### API Gateway에서 통합 권한 제어
클라이언트가 보내는 HTTP 요청에는 요청된 리소스와 HTTP 메서드가 포함됩니다. 시스템이 REST 규약을 따르고 URI 리소스 방식으로 접근 대상을 모델링한다면, API Gateway는 요청에서 직접 접근할 리소스와 필요한 작업을 추출할 수 있습니다. 그런 다음 Security Service를 호출하여 권한을 판단하고, 판단 결과에 따라 사용자가 해당 리소스에 대한 작업 권한이 있는지 결정하고 백엔드 Business Service로 전달합니다. 이 구현 방식은 API Gateway에서 권한 부여 로직을 통합 처리하므로, 각 마이크로서비스는 사용자 권한 부여를 고려할 필요 없이 비즈니스 로직만 처리하면 되어 각 마이크로서비스의 구현을 단순화합니다.
#### 각 마이크로서비스에서 개별 권한 제어
마이크로서비스가 REST 규약을 엄격하게 따르지 않거나, 애플리케이션이 맞춤형 권한 제어를 필요로 하는 경우, 마이크로서비스 내에서 사용자 권한을 개별적으로 판단하고 처리해야 합니다. 이 경우 마이크로서비스의 권한 제어가 더 유연하지만, 각 마이크로서비스는 사용자 권한 부여 데이터를 개별적으로 유지 관리해야 하므로 구현이 더 복잡해집니다.

### 타사 애플리케이션 연동
타사 애플리케이션 연동을 위한 접근 제어는 두 가지 구현 방식이 있습니다:
#### API 토큰
타사 애플리케이션은 애플리케이션에서 발급한 API 토큰을 사용하여 애플리케이션 데이터에 접근합니다. 이 토큰은 사용자가 애플리케이션에서 생성하여 타사 애플리케이션에 제공합니다. 이 경우 일반적으로 타사 애플리케이션은 해당 토큰 소유자 자신의 데이터에만 접근할 수 있으며, 다른 사용자의 민감한 개인 데이터에는 접근할 수 없습니다.

예를 들어, Github는 개인 API 토큰 기능을 제공하며, 사용자는 [Github 개발자 설정 페이지](https://github.com/settings/tokens)에서 토큰을 생성한 다음 해당 토큰을 사용하여 Github API에 접근할 수 있습니다. 토큰 생성 시, 해당 토큰이 사용자의 어떤 데이터에 접근할 수 있는지 설정할 수 있습니다(예: 저장소 정보 보기, 저장소 삭제, 사용자 정보 보기, 사용자 정보 업데이트 등).

API 토큰을 사용하여 Github API에 접근하기
```
curl -u zhaohuabing:fbdf8e8862252ed0f3ba9dba4e328c01ac93aeec https://api.github.com/user

```
API 토큰을 사용하는 것이 사용자 이름/비밀번호를 직접 사용하여 API에 접근하는 것보다 좋은 점은 사용자 비밀번호 노출 위험을 줄이고, 비밀번호를 변경할 필요 없이 언제든지 토큰의 권한을 회수할 수 있다는 것입니다.


API 토큰은 지정된 사용자 데이터에만 접근할 수 있으므로, 사용자가 애플리케이션 내 자신의 데이터를 조작하기 위한 스크립트나 작은 프로그램을 개발하는 데 적합합니다.
#### OAuth
일부 타사 애플리케이션은 다른 사용자의 데이터에 접근하거나 여러 사용자의 데이터를 통합 처리해야 하는 경우 OAuth를 고려할 수 있습니다. OAuth를 사용하면 타사 애플리케이션이 서비스에 접근할 때, 애플리케이션은 사용자에게 타사 애플리케이션에 대한 해당 접근 권한을 부여하도록 요청하고, 사용자의 권한 부여 작업 결과에 따라 접근에 사용될 토큰을 생성하여 타사 애플리케이션의 작업 요청에 대한 접근 제어를 수행합니다.

마찬가지로 Github를 예로 들면, Travis CI, GitBook과 같은 일부 타사 애플리케이션은 OAuth를 통해 Github와 통합됩니다.
OAuth는 시나리오에 따라 다른 인증 흐름을 가지며, 일반적인 인증 흐름은 다음과 같습니다:
* 사용자가 OAuth 클라이언트 프로그램에 요청을 보내고, OAuth 클라이언트 프로그램은 해당 요청을 처리할 때 리소스 서버에 있는 사용자 데이터에 접근해야 함을 발견합니다.
* 클라이언트 프로그램은 사용자 요청을 인증 서버로 리디렉션하며, 이 요청에는 콜백 URL이 포함됩니다.
* 인증 서버는 권한 부여 페이지를 반환하여 사용자에게 OAuth 클라이언트의 리소스 요청에 대한 권한을 부여하도록 요구합니다.
* 사용자가 해당 작업에 권한을 부여하면, 인증 서버는 요청을 클라이언트 프로그램의 콜백 URL로 리디렉션하고, 권한 코드를 클라이언트 프로그램에 반환합니다.
* 클라이언트 프로그램은 권한 코드를 인증 서버로 전송하여 토큰을 요청합니다.
* 인증 서버는 권한 코드를 검증한 후 클라이언트 프로그램에 토큰을 발급합니다.
* 클라이언트 프로그램은 발급받은 토큰을 사용하여 리소스에 접근하고 사용자 요청을 완료합니다.

>참고:
>1. OAuth에서는 기능에 따라 리소스 서버와 인증 서버라는 두 가지 역할을 구분하지만, 구현 시 이 두 역할은 종종 동일한 애플리케이션입니다. 이 흐름도의 각 역할을 Github 예시에 대응시키면, 리소스 서버와 인증 서버는 모두 Github이고, 클라이언트 프로그램은 Travis CI 또는 GitBook이며, 사용자는 Travis CI 또는 GitBook을 직접 사용하는 사용자입니다.
>
>2. 이 흐름에서 왜 토큰을 직접 반환하지 않고 권한 코드(Authorization Code)를 사용하여 토큰을 신청해야 하는지 의아해할 수 있습니다. OAuth가 이렇게 설계된 이유는 클라이언트 콜백 URL로 리디렉션하는 과정에서 사용자 에이전트(브라우저)를 거치게 되는데, 토큰을 직접 전달하면 탈취될 위험이 있기 때문입니다. 권한 코드 방식을 사용하면 토큰 신청 시 클라이언트가 인증 서버와 직접 상호 작용하며, 인증 서버는 클라이언트의 토큰 신청 요청을 처리할 때 클라이언트를 인증하여 다른 사람이 클라이언트 신원을 위조하여 인증 코드를 사용하여 토큰을 신청하는 것을 방지합니다.
>다음은 클라이언트 프로그램이 Authorization Code를 사용하여 토큰을 신청하는 예시이며, client_id와 client_secret은 클라이언트 신원을 확인하는 데 사용됩니다.
>
>```
>POST /oauth/token HTTP/1.1
>Host: authorization-server.com
>  			
>grant_type=authorization_code
>&code=xxxxxxxxxxx
>&redirect_uri=https://example-app.com/redirect
>&client_id=xxxxxxxxxx
>&client_secret=xxxxxxxxxx
>```


![OAuth 인증 흐름](/img/2018-02-03-authentication-and-authorization-of-microservice/oauth_web_server_flow.png)
<center>OAuth 인증 흐름</center>


또한 OAuth를 논할 때, 마이크로서비스 애플리케이션이 OAuth 클라이언트와 OAuth 서버의 두 가지 다른 시나리오에 주의해야 합니다:
  
마이크로서비스 자체의 사용자 인증을 구현할 때, OAuth를 사용하여 마이크로서비스의 사용자 인증을 타사 인증 서비스 제공업체에 위임할 수도 있습니다. 예를 들어, 많은 애플리케이션이 사용자 로그인과 WeChat 또는 QQ의 OAuth 서비스를 통합했습니다.
  
타사 애플리케이션 연동과 마이크로서비스 자체 사용자 인증에 OAuth를 사용하는 목적은 다릅니다. 전자는 마이크로서비스 내 사용자 개인 데이터 접근 권한을 타사 애플리케이션에 부여하기 위한 것이며, 마이크로서비스는 OAuth 아키텍처에서 인증 및 리소스 서버 역할을 합니다. 후자는 잘 알려진 인증 서비스 제공업체가 제공하는 OAuth 인증 서비스를 통합하고 활용하여 번거로운 등록 작업을 단순화하기 위한 것이며, 마이크로서비스는 OAuth 아키텍처에서 클라이언트 역할을 합니다.
  
따라서 우리는 오해를 피하기 위해 이 두 가지 다른 시나리오를 구분해야 합니다.

### 마이크로서비스 간 인증
사용자 및 타사로부터의 북향 트래픽 외에도, 마이크로서비스 간에는 동일한 로컬 네트워크에 있거나 다른 데이터 센터를 넘나들 수 있는 많은 동서향 트래픽이 있습니다. 이러한 서비스 간 트래픽은 제3자의 스니핑 및 공격 위험에 노출될 수 있으므로 보안 제어가 필요합니다.

양방향 SSL을 통해 서비스 간 상호 신원 인증을 구현하고 TLS를 통해 서비스 간 데이터 전송을 암호화할 수 있습니다. 각 서비스에 대해 인증서를 생성해야 하며, 서비스는 서로의 인증서를 통해 신원 인증을 수행합니다. 마이크로서비스 실행 환경에서는 수많은 마이크로서비스 인스턴스가 존재할 수 있으며, 마이크로서비스 인스턴스는 수평 확장으로 서비스 인스턴스가 증가하는 등 동적으로 자주 변경됩니다. 이러한 상황에서 각 서비스에 대한 인증서 생성 및 배포는 매우 어려워집니다. 우리는 사설 인증서 센터(Internal PKI/CA)를 생성하여 각 마이크로서비스에 대한 인증서 관리(발급, 폐기, 갱신 등)를 제공할 수 있습니다.


## 참고

* [How We Solved Authentication and Authorization in Our Microservice Architecture](https://initiate.andela.com/how-we-solved-authentication-and-authorization-in-our-microservice-architecture-994539d1b6e6)
* [How to build your own public key infrastructure](https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/)
* [OAuth 2.0 Authorization Code Request](https://www.oauth.com/oauth2-servers/access-tokens/authorization-code-request/)
* [PKI/CA工作原理及架构](https://www.jianshu.com/p/c65fa3af1c01)
* [深入聊聊微服务架构的身份认证问题](http://www.primeton.com/read.php?id=2390)
